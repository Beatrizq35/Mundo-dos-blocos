MODULE main

-- Define constantes para legibilidade
DEFINE
  TABLE_SIZE := 7; -- Baseado nos diagramas [0..6]
  
  -- Tamanhos inferidos dos diagramas
  size_a := 1;
  size_b := 1;
  size_c := 1;
  size_d := 2;

  -- "Enumeradores" para blocos e alvos
  -- 0=table, 1=a, 2=b, 3=c, 4=d
  target_table := 0;
  target_a     := 1;
  target_b     := 2;
  target_c     := 3;
  target_d     := 4;

VAR
  -- on_X armazena em que o bloco X está (como um inteiro).
  on_a : 0..4;
  on_b : 0..4;
  on_c : 0..4;
  on_d : 0..4;

  -- pos_X armazena a posição inicial na mesa (coluna 0 a 6).
  -- Só é relevante se on_X = target_table.
  pos_a : 0..TABLE_SIZE - size_a;
  pos_b : 0..TABLE_SIZE - size_b;
  pos_c : 0..TABLE_SIZE - size_c;
  pos_d : 0..TABLE_SIZE - size_d;

DEFINE
  -- Um bloco está "clear" (livre) se nenhum outro bloco estiver sobre ele.
  -- Esta lógica agora funciona porque 'target_a', 'target_c' etc.
  -- são interpretados sem ambiguidade como as constantes 1, 3, etc.
  clear_a := (on_b != target_a & on_c != target_a & on_d != target_a);
  clear_b := (on_a != target_b & on_c != target_b & on_d != target_b);
  clear_c := (on_a != target_c & on_b != target_c & on_d != target_c);
  clear_d := (on_a != target_d & on_b != target_d & on_c != target_d);

-- Ações de planejamento como entradas não-determinísticas (IVAR)
IVAR
  action : {
    stay,
    move_a_to_b, move_a_to_c, move_a_to_d, move_a_to_table,
    move_b_to_a, move_b_to_c, move_b_to_d, move_b_to_table,
    move_c_to_a, move_c_to_b, move_c_to_d, move_c_to_table,
    move_d_to_a, move_d_to_b, move_d_to_c, move_d_to_table
  };
  -- Posição alvo na mesa (se a ação for move_X_to_table)
  target_pos : 0..TABLE_SIZE - 1;

ASSIGN
  -- Estado Inicial: S0
  -- c em a, b em d. a na mesa, d na mesa.
  -- Assumindo posições: a em 0, d em 2.
  init(on_a) := target_table;
  init(pos_a) := 0;
  init(on_b) := target_d;
  init(pos_b) := 0; -- Posição irrelevante
  init(on_c) := target_a;
  init(pos_c) := 0; -- Posição irrelevante
  init(on_d) := target_table;
  init(pos_d) := 2;

-- Restrição de estado invariante
INVAR
  -- Restrição de Validade Lógica: um bloco não pode estar sobre si mesmo.
  on_a != target_a &
  on_b != target_b &
  on_c != target_c &
  on_d != target_d;

TRANS
  case
    -- Ação Nula: permanecer no estado
    action = stay :
      next(on_a) = on_a & next(pos_a) = pos_a &
      next(on_b) = on_b & next(pos_b) = pos_b &
      next(on_c) = on_c & next(pos_c) = pos_c &
      next(on_d) = on_d & next(pos_d) = pos_d;
    
    -- --- Ações: Mover Bloco X para Bloco Y ---
    action = move_c_to_a & clear_c & clear_a & size_c <= size_a :
      next(on_c) = target_a &
      next(on_a) = on_a & next(pos_a) = pos_a &
      next(on_b) = on_b & next(pos_b) = pos_b &
      next(on_d) = on_d & next(pos_d) = pos_d &
      next(pos_c) = pos_c; 

    action = move_c_to_b & clear_c & clear_b & size_c <= size_b :
      next(on_c) = target_b &
      next(on_a) = on_a & next(pos_a) = pos_a &
      next(on_b) = on_b & next(pos_b) = pos_b &
      next(on_d) = on_d & next(pos_d) = pos_d &
      next(pos_c) = pos_c;
      
    action = move_c_to_d & clear_c & clear_d & size_c <= size_d :
      next(on_c) = target_d &
      next(on_a) = on_a & next(pos_a) = pos_a &
      next(on_b) = on_b & next(pos_b) = pos_b &
      next(on_d) = on_d & next(pos_d) = pos_d &
      next(pos_c) = pos_c;
      
    -- (Adicionar ações para move_a_to_X, move_b_to_X, move_d_to_X)
    -- ...
      
    -- --- Ações: Mover Bloco X para a Mesa ---
    action = move_c_to_table & clear_c & (target_pos <= TABLE_SIZE - size_c) &
      !(on_a = target_table & target_pos < pos_a + size_a & pos_a < target_pos + size_c) &
      !(on_b = target_table & target_pos < pos_b + size_b & pos_b < target_pos + size_c) &
      !(on_d = target_table & target_pos < pos_d + size_d & pos_d < target_pos + size_c) :
        next(on_c) = target_table & next(pos_c) = target_pos &
        next(on_a) = on_a & next(pos_a) = pos_a &
        next(on_b) = on_b & next(pos_b) = pos_b &
        next(on_d) = on_d & next(pos_d) = pos_d;

    action = move_b_to_table & clear_b & (target_pos <= TABLE_SIZE - size_b) &
      !(on_a = target_table & target_pos < pos_a + size_a & pos_a < target_pos + size_b) &
      !(on_c = target_table & target_pos < pos_c + size_c & pos_c < target_pos + size_b) &
      !(on_d = target_table & target_pos < pos_d + size_d & pos_d < target_pos + size_b) :
        next(on_b) = target_table & next(pos_b) = target_pos &
        next(on_a) = on_a & next(pos_a) = pos_a &
        next(on_c) = on_c & next(pos_c) = pos_c &
        next(on_d) = on_d & next(pos_d) = pos_d;

    action = move_a_to_table & clear_a & (target_pos <= TABLE_SIZE - size_a) &
      !(on_b = target_table & target_pos < pos_b + size_b & pos_b < target_pos + size_a) &
      !(on_c = target_table & target_pos < pos_c + size_c & pos_c < target_pos + size_a) &
      !(on_d = target_table & target_pos < pos_d + size_d & pos_d < target_pos + size_a) :
        next(on_a) = target_table & next(pos_a) = target_pos &
        next(on_b) = on_b & next(pos_b) = pos_b &
        next(on_c) = on_c & next(pos_c) = pos_c &
        next(on_d) = on_d & next(pos_d) = pos_d;
        
    action = move_d_to_table & clear_d & (target_pos <= TABLE_SIZE - size_d) &
      !(on_a = target_table & target_pos < pos_a + size_a & pos_a < target_pos + size_d) &
      !(on_b = target_table & target_pos < pos_b + size_b & pos_b < target_pos + size_d) &
      !(on_c = target_table & target_pos < pos_c + size_c & pos_c < target_pos + size_d) :
        next(on_d) = target_table & next(pos_d) = target_pos &
        next(on_a) = on_a & next(pos_a) = pos_a &
        next(on_b) = on_b & next(pos_b) = pos_b &
        next(on_c) = on_c & next(pos_c) = pos_c;

    -- --- Ação Ilegal / Bloqueada ---
    TRUE :
      next(on_a) = on_a & next(pos_a) = pos_a &
      next(on_b) = on_b & next(pos_b) = pos_b &
      next(on_c) = on_c & next(pos_c) = pos_c &
      next(on_d) = on_d & next(pos_d) = pos_d;
  esac;

-- --- Definição dos Estados Objetivo (Goals) ---
DEFINE
  -- S0 (Inicial): c em a, b em d, a e d na mesa
  state_s0 := (on_c = target_a & on_b = target_d & on_a = target_table & on_d = target_table);

  -- Sf1: c em a. b, d na mesa.
  goal_sf1 := (on_c = target_a & on_a = target_table & on_b = target_table & on_d = target_table);

  -- Sf2: c em d. a, b na mesa.
  goal_sf2 := (on_c = target_d & on_d = target_table & on_a = target_table & on_b = target_table);
  
  -- Sf3: d em c. a, b na mesa.
  goal_sf3 := (on_d = target_c & on_c = target_table & on_a = target_table & on_b = target_table);

  -- Sf4: c em d. a, b na mesa. (Igual a Sf2)
  goal_sf4 := (on_c = target_d & on_d = target_table & on_a = target_table & on_b = target_table);
  
  -- S5 (Aprox.): c em d, d em a, b na mesa.
  goal_s5_approx := (on_c = target_d & on_d = target_a & on_a = target_table & on_b = target_table);
  
  -- S7 (Aprox.): a em c, b na mesa, d na mesa.
  goal_s7_approx := (on_a = target_c & on_c = target_table & on_b = target_table & on_d = target_table);

-- --- Especificações CTL (para encontrar os planos) ---

-- Tarefa 1: S0 -> sf1, sf2, sf3, sf4
SPEC EF goal_sf1
SPEC EF goal_sf2
SPEC EF goal_sf3
-- (Verificar Sf3 é difícil, pois size_d=2 não pode ir sobre size_c=1)
SPEC EF goal_sf4

-- Tarefa 2: S0 -> S5
SPEC EF goal_s5_approx

-- Tarefa 3: S0 -> S7
SPEC EF goal_s7_approx

-- Tarefa 4: Gerar planos negando estados
-- Propriedade "impossível": Bloco d (size 2) sobre a (size 1)
DEFINE impossible_stability := (on_d = target_a);
SPEC EF impossible_stability -- Deve retornar FALSE
